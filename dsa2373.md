## 1/
Problem: A secret spreads among people. After a certain delay, people start sharing it. After a certain forget period, they forget it completely. We need to count how many still know it after n days.

## 2/
Naïve idea: Simulate every person individually — track who knows, who shares, who forgets. But this explodes in complexity for large n. It’s slow, messy, and definitely not interview-friendly.

## 3/
Smarter way: Think in terms of days instead of people. Let’s track how many new people learn the secret on each day. This reduces the problem to simple day-by-day bookkeeping, not person-by-person chaos.

## 4/
For every day:
- Add people who learned delay days ago (they now start sharing).
- Remove people who learned forget days ago (they stop sharing).
This keeps our "active sharers" count precise.

## 5/
With this approach, we just build a daily DP table: dp[i] = people who learn on day i. Finally, sum up the last forget days, because only those haven’t forgotten yet. Clean and efficient.

## 6/
Takeaway: Instead of brute-forcing individual behavior, abstract the problem to time steps + state changes. It’s simpler, scales better, and interviewers love the clarity.








```cpp
class Solution {
public:
    int mod = (long)(1000000007);
    int peopleAwareOfSecret(int n, int delay, int forget) {        
        long noOfPeopleWithSecret = 0;     
        vector<long> dp(n+1, 0);
        dp[1] = 1;        
        for(int i=2; i<=n; i++){            
            long noOfNewPeopleWithSecret = 0;
            if((i-delay)>=1)
                noOfNewPeopleWithSecret = dp[i-delay];           
           
            long noOfPeopleForgetSecret = 0;
            if((i-forget)>=1)
                noOfPeopleForgetSecret = dp[i-forget];
            
            
            noOfPeopleWithSecret = (noOfPeopleWithSecret + noOfNewPeopleWithSecret - noOfPeopleForgetSecret + mod) % mod;           
            
            dp[i] = noOfPeopleWithSecret;
        }
        
        long ans=0;
        for(int i=n-forget+1; i<=n; i++){
            ans = (ans+dp[i])%mod;
        }
        return ((int)ans);
    }
};

```
